"""
Base strategy interface and common components.

All trading strategies inherit from BaseStrategy and implement
the generate_signals method.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional

import pandas as pd


class Position(Enum):
    """Position direction."""
    LONG = 1
    SHORT = -1
    FLAT = 0


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Attributes:
        timestamp: When the signal was generated
        symbol: Asset symbol
        position: Desired position direction
        confidence: Model confidence (0-1)
        target_allocation: Desired allocation (-1 to 1)
        stop_loss: Stop loss price level
        take_profit: Take profit price level
        metadata: Additional signal metadata
    """
    timestamp: pd.Timestamp
    symbol: str
    position: Position
    confidence: float
    target_allocation: float = 0.0
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: dict = field(default_factory=dict)

    def __post_init__(self):
        # Validate confidence
        self.confidence = max(0.0, min(1.0, self.confidence))

        # Validate allocation
        self.target_allocation = max(-1.0, min(1.0, self.target_allocation))


@dataclass
class StrategyConfig:
    """Configuration for trading strategies."""
    min_confidence: float = 0.6
    min_expected_return: float = 0.001
    max_position_size: float = 1.0
    stop_loss_pct: float = 0.02
    take_profit_pct: float = 0.04
    use_trailing_stop: bool = True
    trailing_stop_pct: float = 0.015


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    Strategies must implement:
    - generate_signals: Generate trading signals from data
    - get_required_lookback: Return minimum data requirements
    - get_required_features: Return required feature columns
    """

    def __init__(self, config: StrategyConfig = None):
        """
        Initialize the strategy.

        Args:
            config: Strategy configuration
        """
        self.config = config or StrategyConfig()

    @abstractmethod
    def generate_signals(
        self,
        data: pd.DataFrame,
        symbol: str = "UNKNOWN",
    ) -> list[Signal]:
        """
        Generate trading signals from market data.

        Args:
            data: DataFrame with OHLCV and any computed features
            symbol: Asset symbol

        Returns:
            List of Signal objects
        """
        pass

    @abstractmethod
    def get_required_lookback(self) -> int:
        """
        Return minimum number of data points needed for signal generation.

        This is used by the backtester to ensure sufficient history
        is available before generating signals.
        """
        pass

    @abstractmethod
    def get_required_features(self) -> list[str]:
        """
        Return list of required feature columns.

        Used to validate that input data has necessary columns.
        """
        pass

    def validate_data(self, data: pd.DataFrame) -> bool:
        """
        Validate that data meets requirements.

        Args:
            data: Input DataFrame

        Returns:
            True if valid, raises ValueError otherwise
        """
        # Check length
        if len(data) < self.get_required_lookback():
            raise ValueError(
                f"Insufficient data: {len(data)} rows, "
                f"need at least {self.get_required_lookback()}"
            )

        # Check required features
        required = self.get_required_features()
        missing = [f for f in required if f not in data.columns]
        if missing:
            raise ValueError(f"Missing required features: {missing}")

        return True

    def calculate_stop_loss(
        self,
        entry_price: float,
        position: Position,
        current_atr: Optional[float] = None,
    ) -> float:
        """
        Calculate stop loss level.

        Args:
            entry_price: Entry price
            position: Position direction
            current_atr: Current ATR (if available)

        Returns:
            Stop loss price level
        """
        if current_atr is not None:
            # ATR-based stop loss (2x ATR)
            stop_distance = 2 * current_atr
        else:
            # Percentage-based stop loss
            stop_distance = entry_price * self.config.stop_loss_pct

        if position == Position.LONG:
            return entry_price - stop_distance
        elif position == Position.SHORT:
            return entry_price + stop_distance
        return entry_price

    def calculate_take_profit(
        self,
        entry_price: float,
        position: Position,
        stop_loss: Optional[float] = None,
    ) -> float:
        """
        Calculate take profit level.

        Uses risk-reward ratio if stop loss is provided.

        Args:
            entry_price: Entry price
            position: Position direction
            stop_loss: Stop loss level

        Returns:
            Take profit price level
        """
        if stop_loss is not None:
            # 2:1 risk-reward ratio
            risk = abs(entry_price - stop_loss)
            reward = 2 * risk
        else:
            reward = entry_price * self.config.take_profit_pct

        if position == Position.LONG:
            return entry_price + reward
        elif position == Position.SHORT:
            return entry_price - reward
        return entry_price


class CompositeStrategy(BaseStrategy):
    """
    Combines multiple strategies with configurable weighting.

    Useful for ensemble approaches that combine technical signals
    with model predictions.
    """

    def __init__(
        self,
        strategies: list[BaseStrategy],
        weights: list[float] = None,
        config: StrategyConfig = None,
    ):
        """
        Initialize composite strategy.

        Args:
            strategies: List of strategies to combine
            weights: Weights for each strategy (default: equal)
            config: Strategy configuration
        """
        super().__init__(config)
        self.strategies = strategies
        self.weights = weights or [1.0 / len(strategies)] * len(strategies)

        if len(self.weights) != len(self.strategies):
            raise ValueError("Number of weights must match number of strategies")

    def generate_signals(
        self,
        data: pd.DataFrame,
        symbol: str = "UNKNOWN",
    ) -> list[Signal]:
        """Generate combined signals from all strategies."""
        all_signals: dict[pd.Timestamp, list[tuple[Signal, float]]] = {}

        # Collect signals from all strategies
        for strategy, weight in zip(self.strategies, self.weights):
            try:
                signals = strategy.generate_signals(data, symbol)
                for signal in signals:
                    if signal.timestamp not in all_signals:
                        all_signals[signal.timestamp] = []
                    all_signals[signal.timestamp].append((signal, weight))
            except Exception as e:
                # Log but continue with other strategies
                pass

        # Combine signals at each timestamp
        combined_signals = []
        for timestamp, signal_weights in all_signals.items():
            combined = self._combine_signals(signal_weights, timestamp, symbol)
            if combined is not None:
                combined_signals.append(combined)

        return combined_signals

    def _combine_signals(
        self,
        signal_weights: list[tuple[Signal, float]],
        timestamp: pd.Timestamp,
        symbol: str,
    ) -> Optional[Signal]:
        """Combine weighted signals into a single signal."""
        if not signal_weights:
            return None

        # Weighted average of allocations and confidence
        total_weight = sum(w for _, w in signal_weights)
        weighted_allocation = sum(
            s.target_allocation * w for s, w in signal_weights
        ) / total_weight
        weighted_confidence = sum(
            s.confidence * w for s, w in signal_weights
        ) / total_weight

        # Determine position based on allocation
        if weighted_allocation > 0.1:
            position = Position.LONG
        elif weighted_allocation < -0.1:
            position = Position.SHORT
        else:
            position = Position.FLAT

        # Filter by minimum confidence
        if weighted_confidence < self.config.min_confidence:
            return None

        return Signal(
            timestamp=timestamp,
            symbol=symbol,
            position=position,
            confidence=weighted_confidence,
            target_allocation=weighted_allocation,
            metadata={"source": "composite", "num_signals": len(signal_weights)},
        )

    def get_required_lookback(self) -> int:
        """Return maximum lookback of all strategies."""
        return max(s.get_required_lookback() for s in self.strategies)

    def get_required_features(self) -> list[str]:
        """Return union of all required features."""
        features = set()
        for strategy in self.strategies:
            features.update(strategy.get_required_features())
        return list(features)
